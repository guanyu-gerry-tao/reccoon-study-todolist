import '../App.css'
import './Task.css'
import type { TaskType, TaskId } from '../utils/type.ts'
import { Draggable } from '@hello-pangea/dnd';
import React, { useRef, useEffect, useState } from 'react';
import { useAppContext } from './AppContext.tsx';
import { createBackup, createBulkPayload, optimisticUIUpdate, postPayloadToServer, restoreBackup } from '../utils/utils.ts';

import { motion } from 'motion/react';
import { useNavigate } from 'react-router-dom';

/**
 * This function is used to get the style of the task when it is being dragged
 * @param style - The current style of the task
 * @param snapshot - Callback function from Draggable component
 * @returns style object to input in the Draggable component
 */
function getStyle(style: any, snapshot: any) {
  if (snapshot.isDragging) {
    return {
      ...style,
      boxShadow: `rgba(114, 114, 114, 0.5) 0px 5px 10px 5px`,
      opacity: 0.5,
    }
  }
  return style;
}

// TODO: refine style when dropping task 


/**
 * This component represents a single task (a task card) in the task list.
 * @param taskInfo - The information of the task, defined in App.tsx.
 * @param actions - The object containing actions, defined in App.tsx.
 */
function Task({ task, tasks, }: { task: [TaskId, TaskType], tasks: [TaskId, TaskType][], }) {

  const navigate = useNavigate();

  // Use the AppContext to access the global state and actions
  const { states, actions, setStates } = useAppContext();

  let tempValue = task[1].title; // Temporary variable to store the current value of the input field

  const [textAreaTitleHeight, setTextAreaTitleHeight] = useState<number | null>(null); // State to manage the height of the title textarea
  const [textAreaDescHeight, setTextAreaDescHeight] = useState<number | null>(null); // State to manage the height of the description textarea
  const [isExiting, setIsExiting] = useState<boolean>(false); // State to manage exit animation
  const [exitingToStatus, setExitingToStatus] = useState<string | null>(null); // Track which status we're exiting to

  /**
   * Handle click event on the task title, saves the current value of the input field.
   * This is used to restore the value when the Escape key is pressed.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleClickTitle = (e: React.MouseEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    tempValue = event.currentTarget.value; // Store the current value of the input field
  };

  /**
   * Handle keyboard events on the task title input field.
   * This function updates the task title when Enter is pressed, restores the previous value when Escape is pressed,
   * and deletes the task when Backspace or Delete is pressed.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleTitleKeyboard = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    if (event.key === 'Enter') {
      console.log('Enter pressed');
      event.preventDefault(); // Prevent default Enter key behavior (adding a new line)

      // If the title has changed, update the task title
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);
      try {
        actions.updateTask({ id: task[0], updatedFields: { title: event.currentTarget.value } }, backup);
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task title
        postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
      } catch (error) {
        console.error('Error updating task title:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      }

      event.currentTarget.blur(); // Remove focus from the input field
      console.log(`update title: ${event.currentTarget.title}`)
    }
    if (event.key === 'Escape' && event.currentTarget.value !== '') {
      // Handle Escape key press logic here
      event.currentTarget.value = tempValue; // Restore the previous value
      event.currentTarget.blur(); // Remove focus from the input field
    }
  };

  /**
   * Handle focus lost event on the task title input field.
   * This function deletes the task if the title is empty, or updates the title if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleTitleLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    const currentTarget = e.currentTarget; // Store the current target for later use
    if (currentTarget.value !== task[1].title) {

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);

      // If the title is empty, delete the task
      try {
        actions.updateTask({ id: task[0], updatedFields: { title: currentTarget.value } }, backup); // Update the task title
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task title
        postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
      } catch (error) {
        console.error('Error updating task title:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      }

      console.log(`Title updated to: ${currentTarget.value}`);
    }
  };

  /**
   * Handle focus lost event on the task description input field.
   * This function updates the task description if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleDescLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    const currentTarget = e.currentTarget; // Store the current target for later use
    if (currentTarget.value !== task[1].description) {

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);

      // Create a backup of the current state
      try {
        actions.updateTask({ id: task[0], updatedFields: { description: currentTarget.value } }, backup); // Update the task description
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task description
        postPayloadToServer('/api/bulk', navigate, backup);
      } catch (error) {
        console.error('Error updating task description:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      };

      console.log(`Description updated to: ${currentTarget.value}`);
    }
  }

  /**
   * Handle keyboard events on the task description input field.
   * This function updates the task description when Enter is pressed, restores the previous value when Escape is pressed,
   * and removes focus from the textarea when Enter is pressed without Shift.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleDescKeyboard = async (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault(); // Prevent default Enter key behavior (adding a new line)
      event.currentTarget.blur(); // Remove focus from the textarea
      console.log(`Description updated to: ${event.currentTarget.value}`);

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);

      // If the description has changed, update the task description
      try {
        actions.updateTask({ id: task[0], updatedFields: { description: event.currentTarget.value } }, backup); // Update the task description
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task description
        postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
      } catch (error) {
        console.error('Error updating task description:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
      }

    }
    if (event.key === 'Escape' && event.currentTarget.value !== '') {
      // Handle Escape key press logic here
      event.currentTarget.value = task[1].description || ''; // Restore the previous value
      event.currentTarget.blur(); // Remove focus from the textarea
      if (textAreaRefDesc.current) {
        textAreaRefDesc.current!.style.height = 'auto'; // Reset height to auto
        textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight
      }
    }
  }

  const handleDeleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task[1].status === 'deleted') { // If the task is already deleted, we ask for double confirmation before permanently deleting it
      if (window.confirm(`By double deleting task: ${task[1].title}, you will permanently delete it. Are you sure?`)) {
        // Start exit animation
        setIsExiting(true);
        setExitingToStatus('hardDeleted'); // Special status for hard deletion - always fly up
        
        // create a bulk payload and backup for the delete operation
        const bulkPayload = createBulkPayload();
        const backup = createBackup(states, bulkPayload);
        console.log('tasks after deletion', JSON.stringify(states.projects));
        try {
          actions.hardDeleteTask(task[0], backup);
          optimisticUIUpdate(setStates, backup);
          postPayloadToServer('/api/bulk', navigate, backup); // Send the delete request to the server

        } catch (error) {
          console.error('Error deleting task:', error);
          // If the request fails, restore the previous state from the backup
          restoreBackup(setStates, backup);
          setIsExiting(false); // Reset exit state on error
          setExitingToStatus(null); // Reset target status on error
        };
      };
    } else { // if the task is not deleted, we move it to the deleted status
      // Start exit animation
      setIsExiting(true);
      setExitingToStatus('deleted'); // Set the target status
      
      // create a bulk payload and backup for the move operation
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);

      try {
        actions.moveTask(task[0], 'deleted', 'end', backup, false); // Move the task to the end of the deleted list
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task status
        postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
      } catch (error) {
        console.error('Error moving task to deleted status:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
        setIsExiting(false); // Reset exit state on error
        setExitingToStatus(null); // Reset target status on error
      }
    };
  };

  const handleCompleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task[1].status === 'completed' || task[1].status === 'deleted') {
      // for deleted/completed tasks, there shouldn't be a complete button, so we don't need to handle this case.
      console.warn(`Task with id ${task[0]} is deleted/completed, cannot complete it.`);
    } else { // if the task is not completed, we move it to the completed status
      // Start exit animation
      setIsExiting(true);
      setExitingToStatus('completed'); // Set the target status
      
      // create a bulk payload and backup for the move operation
      const bulkPayload = createBulkPayload();
      const backup = createBackup(states, bulkPayload);

      try {
        actions.moveTask(task[0], 'completed', 'end', backup, false); // Move the task to the end of the completed list
        optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task status
        postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
      } catch (error) {
        console.error('Error moving task to completed status:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, backup);
        setIsExiting(false); // Reset exit state on error
        setExitingToStatus(null); // Reset target status on error
      }

      console.log(`Task ${task[0]} completed: ${task[1].title}`); // Log the completion of the task
    }
  }

  /**
   * Handles the restore button click event.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleRestoreButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div

    // create a bulk payload and backup for the restore operation
    const bulkPayload = createBulkPayload();
    const backup = createBackup(states, bulkPayload);

    try {
      actions.moveTask(task[0], task[1].previousStatus, 'end', backup, false); // Move the task to the end of the todo list
      optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new task status
      postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
    } catch (error) {
      console.error('Error restoring task:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, backup);
    }
  };

  /**
   * Handles changes to the due date input field.
   * @param e - The change event, auto-generated by React.
   */
  const handleDueDateChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const event = e; // Store the current target for later use
    const currentTarget = event.currentTarget; // Store the current target for later use

    // Create a bulk payload and backup for the update operation
    const bulkPayload = createBulkPayload();
    const backup = createBackup(states, bulkPayload);

    try {
      if (!currentTarget.value) {// If the due date input is cleared, set the due date to null
        actions.updateTask({ id: task[0], updatedFields: { dueDate: null } }, backup);

      } else {
        actions.updateTask({ id: task[0], updatedFields: { dueDate: new Date(currentTarget.value) } }, backup);
      }
      optimisticUIUpdate(setStates, backup); // Optimistically update the UI with the new due date
      postPayloadToServer('/api/bulk', navigate, backup); // Send the update to the server
    } catch (error) {
      console.error('Error updating task due date:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, backup);
    }
  };

  const textAreaRefDesc = useRef<HTMLTextAreaElement>(null);
  const textAreaRefTitle = useRef<HTMLTextAreaElement>(null);

  // Adjust the height of the text area based on its content
  // This effect runs whenever the task title or description changes
  // The first = '0px' set the height to minimum height, then set it to scrollHeight to ensure it fits the content
  useEffect(() => {
    if (textAreaRefDesc.current) {
      textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      // textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight.
      setTextAreaDescHeight(textAreaRefDesc.current.scrollHeight);
    }
    if (textAreaRefTitle.current) {
      textAreaRefTitle.current.style.height = textAreaRefTitle.current.scrollHeight + 'px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      // textAreaRefTitle.current.style.height = textAreaRefTitle.current.scrollHeight + 'px'; // Set height to scrollHeight.
      setTextAreaTitleHeight(textAreaRefTitle.current.scrollHeight);
    }
  }, [task[1].title, task[1].description, states.showCompleted, states.showDeleted]); // This effect runs whenever the task title or description changes

  useEffect(() => {
    if (textAreaTitleHeight) {
      setTimeout(() => {
        textAreaRefTitle.current!.style.height = textAreaTitleHeight + 'px'; // Set height to scrollHeight.
      }, 200);
    }
    if (textAreaDescHeight) {
      setTimeout(() => {
        textAreaRefDesc.current!.style.height = textAreaDescHeight + 'px'; // Set height to scrollHeight.
      }, 200);
    }
  }, [textAreaRefTitle.current?.style.height, textAreaRefDesc.current?.style.height]); // This effect runs whenever the text area heights change

  const today = new Date();
  const dueDate = new Date();
  dueDate.setDate(today.getDate() - 2);

  const [onMouseEnter, setOnMouseEnter] = useState<boolean>(false); // State to manage mouse enter event


  // Note: the Draggable component from @hello-pangea/dnd requires a unique draggableId for each task.
  // The setup below is specially for the draggable task component.
  // id: it should be unique and match the taskInfo.id, which is already unique. Specially required by Draggable component.
  // ref: it is used to get the reference of the task element for dragging. Specially Required by Draggable component.
  // ...provided.draggableProps: these are the props required by the Draggable component to make the task draggable.
  // ...provided.dragHandleProps: these are the props required by the Draggable component to make the <div> draggable.
  // style: this is used to apply the draggable styles to the task element. See getStyle function above.
  return (
    <Draggable draggableId={task[0]} index={tasks.indexOf(task)} >
      {
        (provided, snapshot) => {
          const isDragging = snapshot.isDragging || snapshot.isDropAnimating || states.justDragged;
          
          // Determine exit animation based on task status and visibility settings
          const getExitAnimation = () => {
            if (!isExiting) return {};
            
            // Use exitingToStatus to determine target, fallback to current status
            const targetStatus = exitingToStatus || task[1].status;
            
            // For tasks going to deleted status
            if (targetStatus === 'deleted') {
              return states.showDeleted 
                ? { opacity: 0, scale: 0.8, x: 0, y: 0 } // Fly to deleted bar (visible)
                : { opacity: 0, scale: 0.5, y: -50 }; // Fly up and disappear (hidden)
            }
            
            // For tasks going to completed status
            if (targetStatus === 'completed') {
              return states.showCompleted
                ? { opacity: 0, scale: 0.8, x: 0, y: 0 } // Fly to completed bar (visible)
                : { opacity: 0, scale: 0.5, y: -50 }; // Fly up and disappear (hidden)
            }
            
            // Default upward animation
            return { opacity: 0, scale: 0.5, y: -50 };
          };

          return (
            <motion.div className="cardContainer"
              layout={!isDragging && !isExiting}
              layoutId={isDragging ? undefined : task[0]}
              initial={isDragging ? { opacity: 0.1 } : isExiting ? { opacity: 1, scale: 1 } : { opacity: 0.1 }}
              animate={isDragging ? { opacity: 1 } : isExiting ? getExitAnimation() : { opacity: 1 }}
              exit={getExitAnimation()}
              transition={
                isDragging ? { duration: 0 } : 
                isExiting ? { duration: 0.2, ease: "easeOut" } : 
                { type: 'spring', stiffness: 300, damping: 25 }
              }
              onMouseEnter={() => setOnMouseEnter(true)}
              onMouseLeave={() => setOnMouseEnter(false)}
            >
              <div
                className={`card`}
                id={task[0]}
                ref={provided.innerRef}
                {...provided.draggableProps}
                {...provided.dragHandleProps}
                style={{
                  ...getStyle(provided.draggableProps.style, snapshot),
                }}
              >

                <div className='taskDragHandler'
                ></div>

                <div className='cardContent' >
                  <textarea
                    className='taskTitle'
                    placeholder='Add a title...'
                    defaultValue={task[1].title}
                    ref={textAreaRefTitle}
                    onChange={(e) => {
                      const event = e; // Store the current target for later use
                      event.currentTarget.style.height = '0px';
                      event.currentTarget.style.height = event.currentTarget.scrollHeight + 'px';
                      setTextAreaTitleHeight(event.currentTarget.scrollHeight);
                    }}
                    onClick={handleClickTitle}
                    onKeyDown={handleTitleKeyboard}
                    onBlur={handleTitleLostFocus} />

                  <textarea
                    className='taskDesc'
                    defaultValue={task[1].description}
                    placeholder='Add a description...'
                    ref={textAreaRefDesc}
                    onChange={(e) => {
                      const event = e; // Store the current target for later use
                      event.currentTarget.style.height = '0px';
                      event.currentTarget.style.height = event.currentTarget.scrollHeight + 'px';
                      setTextAreaDescHeight(event.currentTarget.scrollHeight);
                    }}
                    onKeyDown={handleDescKeyboard}
                    onBlur={handleDescLostFocus}
                  />

                  <input type='date'
                    className='taskDueDate'
                    defaultValue={task[1].dueDate ? new Date(task[1].dueDate).toISOString().slice(0, 10) : undefined}
                    onChange={handleDueDateChange}
                    style={{
                      color: task[1].dueDate && task[1].dueDate < dueDate ? 'red' : '',
                      fontWeight: task[1].dueDate && task[1].dueDate < dueDate ? 'normal' : '',
                      opacity: task[1].dueDate && task[1].dueDate < dueDate ? '1' : ''
                    }}
                  />

                  {/* TODO: add subtasks function: click to drop down subtasks, subtasks can be added, deleted, updated, dragged */}

                </div>
                <div className="deleteTaskButton"
                  style={{
                    opacity: onMouseEnter && !isDragging ? 1 : 0,
                    visibility: onMouseEnter && !isDragging ? 'visible' : 'hidden',
                    pointerEvents: onMouseEnter && !isDragging ? 'auto' : 'none'
                  }}
                  onClick={handleDeleteButton}
                >
                </div>

                {task[1].status !== 'deleted' && task[1].status !== 'completed' && (
                  <div className="completeTaskButton"
                    style={{
                      opacity: onMouseEnter && !isDragging ? 1 : 0,
                      visibility: onMouseEnter && !isDragging ? 'visible' : 'hidden',
                      pointerEvents: onMouseEnter && !isDragging ? 'auto' : 'none'
                    }}
                    onClick={handleCompleteButton}
                  >
                  </div>)
                }


                {(task[1].status === "deleted" || task[1].status === "completed") && (
                  <div className="restoreTaskButton"
                    style={{
                      opacity: onMouseEnter && !isDragging ? 1 : 0,
                      visibility: onMouseEnter && !isDragging ? 'visible' : 'hidden',
                      pointerEvents: onMouseEnter && !isDragging ? 'auto' : 'none'
                    }}
                    onClick={handleRestoreButton}
                  >
                  </div>)
                }
              </div>
            </motion.div>
          )
        }
      }
    </Draggable >
  )
}

export default Task


