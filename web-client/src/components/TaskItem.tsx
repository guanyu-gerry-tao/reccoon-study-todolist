import '../App.css'
import './TaskItem.css'
import type { Task, TaskId } from '../utils/type.ts'
import React, { useRef, useEffect, useState } from 'react';
import { useAppContext } from './AppContext.tsx';
import { createBulkPayload, optimisticUIUpdate, postPayloadToServer, restoreBackup } from '../utils/utils.ts';
import { motion } from 'framer-motion';
import { useNavigate } from 'react-router-dom';
import { useSortable } from '@dnd-kit/sortable';

/**
 * This component represents a single task (a task card) in the task list.
 * @param task - The information of the task
 * @param tasks - All tasks in the current container
 */
function TaskItem({ taskId, placeholder }: { taskId: TaskId, placeholder?: boolean }) {

  const navigate = useNavigate();

  // Use the AppContext to access the global state and actions
  const { states, actions, setStates } = useAppContext();

  const task = states.tasks[taskId]; // Get the task information from the global state

  // dnd-kit sortable hook
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    isDragging,
  } = useSortable({
    id: taskId, // Use task ID as unique identifier
  });

  let tempValue = task.title; // Temporary variable to store the current value of the input field

  const [textAreaTitleHeight, setTextAreaTitleHeight] = useState<number | null>(null); // State to manage the height of the title textarea
  const [textAreaDescHeight, setTextAreaDescHeight] = useState<number | null>(null); // State to manage the height of the description textarea

  /**
   * Handle click event on the task title, saves the current value of the input field.
   * This is used to restore the value when the Escape key is pressed.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleClickTitle = (e: React.MouseEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    tempValue = event.currentTarget.value; // Store the current value of the input field
  };

  /**
   * Handle keyboard events on the task title input field.
   * This function updates the task title when Enter is pressed, restores the previous value when Escape is pressed,
   * and deletes the task when Backspace or Delete is pressed.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleTitleKeyboard = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    if (event.key === 'Enter') {
      console.log('Enter pressed');
      event.preventDefault(); // Prevent default Enter key behavior (adding a new line)

      // If the title has changed, update the task title
      const bulkPayload = createBulkPayload(states);
      try {
        actions.updateItem('task', taskId, { title: event.currentTarget.value }, bulkPayload); // Update the task title
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task title
        postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
      } catch (error) {
        console.error('Error updating task title:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      }

      event.currentTarget.blur(); // Remove focus from the input field
      console.log(`update title: ${event.currentTarget.title}`)
    }
    if (event.key === 'Escape' && event.currentTarget.value !== '') {
      // Handle Escape key press logic here
      event.currentTarget.value = tempValue; // Restore the previous value
      event.currentTarget.blur(); // Remove focus from the input field
    }
  };

  /**
   * Handle focus lost event on the task title input field.
   * This function deletes the task if the title is empty, or updates the title if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleTitleLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    const currentTarget = e.currentTarget; // Store the current target for later use
    if (currentTarget.value !== task.title) {

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload(states);

      // If the title is empty, delete the task
      try {
        actions.updateItem('task', taskId, { title: currentTarget.value }, bulkPayload); // Update the task title
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task title
        postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
      } catch (error) {
        console.error('Error updating task title:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      }

      console.log(`Title updated to: ${currentTarget.value}`);
    }
  };

  /**
   * Handle focus lost event on the task description input field.
   * This function updates the task description if it has changed.
   * @param e - The focus event, auto-generated by React.
   */
  const handleDescLostFocus = async (e: React.FocusEvent<HTMLTextAreaElement>) => {
    const currentTarget = e.currentTarget; // Store the current target for later use
    if (currentTarget.value !== task.description) {

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload(states);

      // Create a backup of the current state
      try {
        actions.updateItem('task', taskId, { description: currentTarget.value }, bulkPayload); // Update the task description
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task description
        postPayloadToServer('/api/bulk', navigate, bulkPayload);
      } catch (error) {
        console.error('Error updating task description:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      };

      console.log(`Description updated to: ${currentTarget.value}`);
    }
  }

  /**
   * Handle keyboard events on the task description input field.
   * This function updates the task description when Enter is pressed, restores the previous value when Escape is pressed,
   * and removes focus from the textarea when Enter is pressed without Shift.
   * @param e - The keyboard event, auto-generated by React.
   */
  const handleDescKeyboard = async (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const event = e; // Store the current target for later use
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault(); // Prevent default Enter key behavior (adding a new line)
      event.currentTarget.blur(); // Remove focus from the textarea
      console.log(`Description updated to: ${event.currentTarget.value}`);

      // create a bulk payload and backup for the update operation
      const bulkPayload = createBulkPayload(states);

      // If the description has changed, update the task description
      try {
        actions.updateItem('task', taskId, { description: event.currentTarget.value }, bulkPayload); // Update the task description
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task description
        postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
      } catch (error) {
        console.error('Error updating task description:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      }

    }
    if (event.key === 'Escape' && event.currentTarget.value !== '') {
      // Handle Escape key press logic here
      event.currentTarget.value = task.description || ''; // Restore the previous value
      event.currentTarget.blur(); // Remove focus from the textarea
      if (textAreaRefDesc.current) {
        textAreaRefDesc.current!.style.height = 'auto'; // Reset height to auto
        textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight
      }
    }
  }

  const handleDeleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task.status === 'deleted') { // If the task is already deleted, we ask for double confirmation before permanently deleting it
      if (window.confirm(`By double deleting task: ${task.title}, you will permanently delete it. Are you sure?`)) {
        // create a bulk payload and backup for the delete operation
        const bulkPayload = createBulkPayload(states);
        console.log('tasks after deletion', JSON.stringify(states.projects));
        try {
          actions.deleteItem('task', taskId, states.tasks, bulkPayload);
          optimisticUIUpdate(setStates, bulkPayload);
          postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the delete request to the server

        } catch (error) {
          console.error('Error deleting task:', error);
          // If the request fails, restore the previous state from the backup
          restoreBackup(setStates, bulkPayload);
        };
      };
    } else { // if the task is not deleted, we move it to the deleted status
      // create a bulk payload and backup for the move operation
      const bulkPayload = createBulkPayload(states);
      try {
        actions.moveTask(taskId, 'deleted', null, 'end', bulkPayload); // Move the task to the end of the deleted list
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task status
        postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
      } catch (error) {
        console.error('Error moving task to deleted status:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      }
    };
  };

  const handleCompleteButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div
    if (task.status === 'completed' || task.status === 'deleted') {
      // for deleted/completed tasks, there shouldn't be a complete button, so we don't need to handle this case.
      console.warn(`TaskItem with id ${taskId} is deleted/completed, cannot complete it.`);
    } else { // if the task is not completed, we move it to the completed status
      // create a bulk payload and backup for the move operation
      const bulkPayload = createBulkPayload(states);
      try {
        actions.moveTask(taskId, 'completed', null, 'end', bulkPayload); // Move the task to the end of the completed list
        optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task status
        postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
      } catch (error) {
        console.error('Error moving task to completed status:', error);
        // If the request fails, restore the previous state from the backup
        restoreBackup(setStates, bulkPayload);
      }

      console.log(`TaskItem ${taskId} completed: ${task.title}`); // Log the completion of the task
    }
  }

  /**
   * Handles the restore button click event.
   * @param e - The mouse event, auto-generated by React.
   */
  const handleRestoreButton = async (e: React.MouseEvent<HTMLDivElement>) => {
    const event = e; // Store the current target for later use
    event.stopPropagation(); // Prevent the click event from propagating to the parent div

    // create a bulk payload and backup for the restore operation
    const bulkPayload = createBulkPayload(states);
    try {
      actions.moveTask(taskId, task.previousStatus, null, 'end', bulkPayload); // Move the task to the end of the todo list
      optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new task status
      postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
    } catch (error) {
      console.error('Error restoring task:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, bulkPayload);
    }
  };

  /**
   * Handles changes to the due date input field.
   * @param e - The change event, auto-generated by React.
   */
  const handleDueDateChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const event = e; // Store the current target for later use
    const currentTarget = event.currentTarget; // Store the current target for later use

    // Create a bulk payload and backup for the update operation
    const bulkPayload = createBulkPayload(states);
    try {
      if (!currentTarget.value) {// If the due date input is cleared, set the due date to null
        actions.updateItem('task', taskId, { dueDate: null }, bulkPayload);

      } else {
        actions.updateItem('task', taskId, { dueDate: new Date(currentTarget.value) }, bulkPayload);
      }
      optimisticUIUpdate(setStates, bulkPayload); // Optimistically update the UI with the new due date
      postPayloadToServer('/api/bulk', navigate, bulkPayload); // Send the update to the server
    } catch (error) {
      console.error('Error updating task due date:', error);
      // If the request fails, restore the previous state from the backup
      restoreBackup(setStates, bulkPayload);
    }
  };

  const textAreaRefDesc = useRef<HTMLTextAreaElement>(null);
  const textAreaRefTitle = useRef<HTMLTextAreaElement>(null);

  // Adjust the height of the text area based on its content
  // This effect runs whenever the task title or description changes
  // The first = '0px' set the height to minimum height, then set it to scrollHeight to ensure it fits the content
  useEffect(() => {
    if (textAreaRefDesc.current) {
      textAreaRefDesc.current.style.height = '2px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      textAreaRefDesc.current.style.height = textAreaRefDesc.current.scrollHeight + 'px'; // Set height to scrollHeight.
      setTextAreaDescHeight(textAreaRefDesc.current.scrollHeight);
    }
    if (textAreaRefTitle.current) {
      textAreaRefTitle.current.style.height = '2px'; // Reset height to minimum height, ensure it was smaller and then get larger.
      textAreaRefTitle.current.style.height = textAreaRefTitle.current.scrollHeight + 'px'; // Set height to scrollHeight.
      setTextAreaTitleHeight(textAreaRefTitle.current.scrollHeight);
    }
  }, [task.title, task.description]); // This effect runs whenever the task title or description changes

  useEffect(() => {
    if (textAreaTitleHeight) {
      setTimeout(() => {
        if (textAreaRefTitle.current) {
          textAreaRefTitle.current.style.height = textAreaTitleHeight + 'px'; // Set height to scrollHeight.
        }
      }, 200);
    }
    if (textAreaDescHeight) {
      setTimeout(() => {
        if (textAreaRefDesc.current)
          textAreaRefDesc.current.style.height = textAreaDescHeight + 'px'; // Set height to scrollHeight.
      }, 200);
    }
  }, [textAreaRefTitle.current?.style.height, textAreaRefDesc.current?.style.height]); // This effect runs whenever the text area heights change

  const today = new Date();
  const dueDate = new Date();
  dueDate.setDate(today.getDate() - 2);

  return (
    <motion.div
      ref={setNodeRef}
      className="cardContainer"
      layoutId={placeholder ? task.id : undefined}  // 魔法属性：布局动画
      layout                       // 魔法属性：自动检测布局变化
      // initial={{ opacity: 0, y: 20 }}     // 初始状态
      animate={{
        opacity: 1,   // 拖拽时完全隐藏原位置
        y: transform?.y || 0,
        x: transform?.x || 0,      // 使用 Motion 处理拖拽变换
        // scale: isDragging ? 1.03 : 1,     // 拖拽时放大
        // zIndex: isDragging ? 1000 : 1,    // 拖拽时提到最前
      }}
      // transition={states.activeId ? {
      //   type: false,            // 弹性动画
      //   stiffness: 400,
      //   damping: 30,
      //   layout: { duration: 0.2 }, // 布局动画持续时间
      // } : undefined}
      // whileHover={{
      //   // scale: 1.01,
      //   boxShadow: "0 2px 8px rgba(0,0,0,0.1)"
      // }}
      // whileDrag={{
      //   scale: 1.05,
      //   rotate: 1,
      //   boxShadow: "0 10px 30px rgba(0,0,0,0.2)"
      // }}
      // exit={states.activeId ? { opacity: 0, y: -20 } : undefined}       // 退出动画
      {...attributes}              // dnd-kit 无障碍属性
      {...listeners}             // dnd-kit 拖拽监听器
      style={{ opacity: isDragging ? 0 : 1 }} // 拖拽时完全隐藏原位置
    >
      <div
        className="card"
      >
        <div className='taskDragHandler'
        ></div>

        <div className='cardContent'>
          <textarea
            className='taskTitle'
            placeholder='Add a title...'
            defaultValue={task.title}
            ref={textAreaRefTitle}
            onChange={(e) => {
              const event = e; // Store the current target for later use
              event.currentTarget.style.height = '0px';
              event.currentTarget.style.height = event.currentTarget.scrollHeight + 'px';
              setTextAreaTitleHeight(event.currentTarget.scrollHeight);
            }}
            onClick={handleClickTitle}
            onKeyDown={handleTitleKeyboard}
            onBlur={handleTitleLostFocus} />

          <textarea
            className='taskDesc'
            defaultValue={task.description}
            placeholder='Add a description...'
            ref={textAreaRefDesc}
            onChange={(e) => {
              const event = e; // Store the current target for later use
              event.currentTarget.style.height = '0px';
              event.currentTarget.style.height = event.currentTarget.scrollHeight + 'px';
              setTextAreaDescHeight(event.currentTarget.scrollHeight);
            }}
            onKeyDown={handleDescKeyboard}
            onBlur={handleDescLostFocus}
          />

          <input type='date'
            className='taskDueDate'
            defaultValue={task.dueDate ? new Date(task.dueDate).toISOString().slice(0, 10) : undefined}
            onChange={handleDueDateChange}
            style={{
              color: task.dueDate && task.dueDate < dueDate ? 'red' : '',
              fontWeight: task.dueDate && task.dueDate < dueDate ? 'normal' : '',
              opacity: task.dueDate && task.dueDate < dueDate ? '1' : ''
            }}
          />
        </div>
      </div>

      <motion.div
        className="deleteTaskButton"
        initial={{ scale: 0 }}
        animate={{
          scale: states.editMode ? 1 : 0,
          opacity: states.editMode ? 1 : 0
        }}
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        style={{
          visibility: states.editMode ? 'visible' : 'hidden',
          pointerEvents: states.editMode ? 'auto' : 'none'
        }}
        onClick={handleDeleteButton}
      />

      {task.status !== 'deleted' && task.status !== 'completed' && (
        <motion.div
          className="completeTaskButton"
          initial={{ scale: 0 }}
          animate={{
            scale: states.editMode ? 1 : 0,
            opacity: states.editMode ? 1 : 0
          }}
          whileHover={{ scale: 1.1 }}
          whileTap={{ scale: 0.9 }}
          style={{
            visibility: states.editMode ? 'visible' : 'hidden',
            pointerEvents: states.editMode ? 'auto' : 'none'
          }}
          onClick={handleCompleteButton}
        />
      )}

      {(task.status === "deleted" || task.status === "completed") && (
        <motion.div
          className="restoreTaskButton"
          initial={{ scale: 0 }}
          animate={{
            scale: states.editMode ? 1 : 0,
            opacity: states.editMode ? 1 : 0
          }}
          whileHover={{ scale: 1.1 }}
          whileTap={{ scale: 0.9 }}
          style={{
            visibility: states.editMode ? 'visible' : 'hidden',
            pointerEvents: states.editMode ? 'auto' : 'none'
          }}
          onClick={handleRestoreButton}
        />
      )}
    </motion.div>
  )
}

export default TaskItem


